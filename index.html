<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>ê³µë¶€ í€´ì¦ˆ (ì •ë‹µ ë§¤í•‘ í¬í•¨)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#f3f6fb; color:#1f2937; padding:22px; }
  .container{ max-width:900px; margin:24px auto; background:white; padding:22px; border-radius:12px; box-shadow:0 6px 24px rgba(16,24,40,0.08); }
  h1{ margin:0 0 10px 0; font-size:22px; }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; margin:12px 0; }
  button{ padding:10px 14px; border-radius:8px; border:0; cursor:pointer; font-weight:600; }
  .btn-primary{ background:#2563eb; color:white; }
  .btn-success{ background:#16a34a; color:white; }
  .btn-danger{ background:#dc2626; color:white; }
  .btn-muted{ background:#e5e7eb; color:#111827; }
  pre{ white-space:pre-wrap; text-align:left; background:#f8fafc; padding:16px; border-radius:8px; font-size:16px; }
  #answer { margin-top:10px; font-weight:700; color:#0f172a; }
  .meta{ font-size:13px; color:#6b7280; margin-top:8px; }
  .file-row{ display:flex; gap:8px; align-items:center; margin-bottom:12px; }
  .small{ font-size:13px; color:#374151; }
</style>
</head>
<body>
  <div class="container">
    <h1>ê³µë¶€ í€´ì¦ˆ â€” ì •ë‹µ ë§¤í•‘ í¬í•¨</h1>
    <p class="small">`ê³µë¶€.txt`ì™€ `ì •ë‹µ.txt`ë¥¼ ê°ê° ì„ íƒí•˜ì„¸ìš”. (ê°™ì€ ë””ë ‰í† ë¦¬ì— ìˆì–´ë„ ë©ë‹ˆë‹¤.)</p>

    <div class="file-row">
      <label>
        ë¬¸ì œ íŒŒì¼ (.txt) 
        <input id="fileQuestions" type="file" accept=".txt" />
      </label>
      <label>
        ì •ë‹µ íŒŒì¼ (.txt)
        <input id="fileAnswers" type="file" accept=".txt" />
      </label>
      <button id="loadBtn" class="btn-primary">ë¶ˆëŸ¬ì˜¤ê¸° & ì„ê¸°</button>
      <button id="clearWrong" class="btn-muted">í‹€ë¦°ë¬¸ì œ ì´ˆê¸°í™”</button>
    </div>

    <div id="quizArea" style="display:none;">
      <div class="meta" id="metaInfo"></div>
      <pre id="questionBox">ë¬¸ì œê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</pre>

      <div class="controls">
        <button id="showAnswerBtn" class="btn-muted">ì •ë‹µ ë³´ê¸°</button>
        <button id="correctBtn" class="btn-success">ë§ìŒ âœ…</button>
        <button id="wrongBtn" class="btn-danger">í‹€ë¦¼ âŒ</button>
        <button id="nextBtn" class="btn-primary">ë‹¤ìŒ â–¶</button>
        <button id="toggleWrongMode" class="btn-muted">í‹€ë¦° ë¬¸ì œë§Œ ë³´ê¸°: ë”</button>
        <button id="shuffleBtn" class="btn-muted">ë‹¤ì‹œ ì„ê¸° ğŸ”€</button>
        <button id="exportWrong" class="btn-muted">í‹€ë¦°ë¬¸ì œ ë‚´ë³´ë‚´ê¸°(.txt)</button>
      </div>

      <div id="answer" style="display:none;"></div>
      <div class="meta" id="progress"></div>
    </div>
  </div>

<script>
/*
  ë™ì‘ ìš”ì•½:
   - ê³µë¶€.txt: ë²ˆí˜¸(ì˜ˆ: "1.") ê¸°ì¤€ìœ¼ë¡œ ë¬¸ì œ ë¶„ë¦¬ (ë²ˆí˜¸ ë³´ì¡´)
   - ì •ë‹µ.txt: ì¤„ë‹¨ìœ„/ê³µë°±ë‹¨ìœ„ë¡œ ì •ë‹µ ë°°ì—´ ìƒì„± -> ì¸ë±ìŠ¤ ê¸°ì¤€ìœ¼ë¡œ ë¬¸ì œì™€ ë§¤í•‘
   - ë¬¸ì œì…‹ì€ ì„ê¸°(shuffle)ë˜ì§€ë§Œ ë§¤í•‘ì€ ì›ë˜ ì¸ë±ìŠ¤(ë¬¸ì œ ë²ˆí˜¸ìˆœ) ê¸°ì¤€ìœ¼ë¡œ ìœ ì§€
   - í‹€ë¦° ë¬¸ì œëŠ” localStorageì— ì €ì¥ë¨ (key: "quiz_wrong_list")
*/

const fileQ = document.getElementById('fileQuestions');
const fileA = document.getElementById('fileAnswers');
const loadBtn = document.getElementById('loadBtn');
const quizArea = document.getElementById('quizArea');
const questionBox = document.getElementById('questionBox');
const showAnswerBtn = document.getElementById('showAnswerBtn');
const answerDiv = document.getElementById('answer');
const correctBtn = document.getElementById('correctBtn');
const wrongBtn = document.getElementById('wrongBtn');
const nextBtn = document.getElementById('nextBtn');
const metaInfo = document.getElementById('metaInfo');
const progress = document.getElementById('progress');
const toggleWrongModeBtn = document.getElementById('toggleWrongMode');
const shuffleBtn = document.getElementById('shuffleBtn');
const clearWrongBtn = document.getElementById('clearWrong');
const exportWrongBtn = document.getElementById('exportWrong');

let rawQuestions = [];   // ì›ë³¸ ë¬¸ì œ ê°ì²´ ë°°ì—´ {num: int, text: string}
let answers = [];        // ì •ë‹µ ë°°ì—´, ì¸ë±ìŠ¤ 0 -> 1ë²ˆ ë¬¸ì œ ì •ë‹µ (we'll store at index num-1)
let workList = [];       // ì„ì¸ ë¬¸ì œ ì°¸ì¡° (ì°¸ì¡°: rawQuestions elements)
let currentIndex = 0;
let wrongSet = new Set(JSON.parse(localStorage.getItem('quiz_wrong_list') || '[]'));
let mode = 'all'; // 'all' or 'wrong'

function readFileAsText(file) {
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = e => res(e.target.result);
    r.onerror = e => rej(e);
    r.readAsText(file, 'utf-8');
  });
}

function splitQuestions(text) {
  // ë¬¸ì œ í…ìŠ¤íŠ¸ë¥¼ "ìˆ«ì. " ë¡œ êµ¬ë¶„. ë²ˆí˜¸ê°€ ì•ˆ ë¶™ì–´ìˆìœ¼ë©´ ë¼ì¸ë³„ë¡œ ì²˜ë¦¬.
  // ì •ê·œì‹: ìˆ«ìì™€ ì ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë¸”ë¡ì„ ì°¾ì•„ ë¶„ë¦¬
  const trimmed = text.trim();
  // find all matches for groups that start with "^ìˆ«ì." using global multiline
  const blocks = [];
  // If there are numbered items, split by lines that start with digit+.
  if (/^\s*\d+\./m.test(trimmed)) {
    // split by positions of lines starting with number dot
    const parts = trimmed.split(/\n(?=\s*\d+\.)/g);
    for (const p of parts) {
      const m = p.match(/^\s*(\d+)\.\s*/);
      if (m) {
        const num = parseInt(m[1],10);
        const body = p.replace(/^\s*\d+\.\s*/, '').trim();
        blocks.push({num, text: body});
      } else {
        // fallback: push as-is with auto-num
        blocks.push({num: blocks.length+1, text: p.trim()});
      }
    }
  } else {
    // No numbered format: treat each non-empty line as one question
    const lines = trimmed.split(/\r?\n/).map(s => s.trim()).filter(s => s.length>0);
    lines.forEach((ln,i) => blocks.push({num: i+1, text: ln}));
  }
  return blocks;
}

function parseAnswers(text) {
  // ì •ë‹µíŒŒì¼: ê°€ëŠ¥í•œ í•œ ê° ì¤„ì„ í•˜ë‚˜ì˜ ì •ë‹µìœ¼ë¡œ ê°„ì£¼.
  // ì—¬ëŸ¬ê°œì˜ ì—°ì† ê³µë°± ë¼ì¸ì„ ë¬´ì‹œ.
  const lines = text.split(/\r?\n/).map(s => s.trim()).filter(s => s.length>0);
  // If each line looks like "1. ë‹µ", remove leading "ë²ˆí˜¸." if present.
  return lines.map(l => l.replace(/^\s*\d+\.\s*/, '').trim());
}

function shuffle(array) {
  for (let i=array.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function buildWorkList() {
  // workListëŠ” rawQuestions ì°¸ì¡°ë¥¼ ì„ì€ ë°°ì—´
  workList = rawQuestions.slice();
  shuffle(workList);
  currentIndex = 0;
}

function displayCurrent() {
  answerDiv.style.display = 'none';
  answerDiv.textContent = '';
  quizArea.style.display = 'block';
  if (mode === 'all' && workList.length===0) {
    questionBox.textContent = 'ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤. íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”.';
    progress.textContent = '';
    metaInfo.textContent = '';
    return;
  }
  if (mode === 'wrong') {
    const wrongArray = workList.filter(q => wrongSet.has(q.num));
    if (wrongArray.length===0) {
      questionBox.textContent = 'ğŸ“š í‹€ë¦° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.';
      progress.textContent = '';
      metaInfo.textContent = '';
      return;
    }
    if (!wrongArray[currentIndex]) currentIndex = 0;
    const q = wrongArray[currentIndex];
    questionBox.textContent = `${q.num}. ${q.text}`;
    progress.textContent = `${currentIndex+1} / ${wrongArray.length} (í‹€ë¦° ë¬¸ì œë§Œ)`;
    metaInfo.textContent = `ì›ë³¸ ë¬¸ì œ ìˆ˜: ${rawQuestions.length} / ì €ì¥ëœ í‹€ë¦° ë¬¸ì œ ìˆ˜: ${wrongSet.size}`;
    return;
  }
  // all mode
  if (workList.length===0) {
    questionBox.textContent = 'ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.';
    progress.textContent = '';
    metaInfo.textContent = '';
    return;
  }
  if (!workList[currentIndex]) currentIndex = 0;
  const q = workList[currentIndex];
  questionBox.textContent = `${q.num}. ${q.text}`;
  progress.textContent = `${currentIndex+1} / ${workList.length} (ì „ì²´ ëª¨ë“œ)`;
  metaInfo.textContent = `ì›ë³¸ ë¬¸ì œ ìˆ˜: ${rawQuestions.length} / ì €ì¥ëœ í‹€ë¦° ë¬¸ì œ ìˆ˜: ${wrongSet.size}`;
}

showAnswerBtn.addEventListener('click', () => {
  // í˜„ì¬ í‘œì‹œëœ ë¬¸ì œì˜ ë²ˆí˜¸ë¥¼ ì°¾ì•„ ì •ë‹µ ë°°ì—´ì—ì„œ ë½‘ì•„ ë³´ì—¬ì¤€ë‹¤.
  answerDiv.style.display = 'block';
  const q = getCurrentQuestion();
  if (!q) {
    answerDiv.textContent = 'ì •ë‹µ ì—†ìŒ';
    return;
  }
  const ans = answers[q.num - 1];
  answerDiv.textContent = ans ? `ì •ë‹µ: ${ans}` : 'ì •ë‹µ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.';
});

function getCurrentQuestion() {
  if (mode === 'wrong') {
    const wrongArray = workList.filter(q => wrongSet.has(q.num));
    return wrongArray[currentIndex] || null;
  } else {
    return workList[currentIndex] || null;
  }
}

correctBtn.addEventListener('click', () => {
  const q = getCurrentQuestion();
  if (!q) return;
  // ë§ìŒ: í‹€ë¦°ì…‹ì—ì„œ ì œê±°(ìˆë‹¤ë©´)
  if (wrongSet.has(q.num)) {
    wrongSet.delete(q.num);
    saveWrongSet();
  }
  nextQuestion();
});

wrongBtn.addEventListener('click', () => {
  const q = getCurrentQuestion();
  if (!q) return;
  wrongSet.add(q.num);
  saveWrongSet();
  nextQuestion();
});

function nextQuestion() {
  const list = (mode==='wrong') ? workList.filter(q=>wrongSet.has(q.num)) : workList;
  if (list.length===0) {
    displayCurrent();
    return;
  }
  currentIndex++;
  if (currentIndex >= list.length) currentIndex = 0;
  displayCurrent();
}

nextBtn.addEventListener('click', () => {
  answerDiv.style.display = 'none';
  nextQuestion();
});

toggleWrongModeBtn.addEventListener('click', () => {
  if (mode === 'all') {
    mode = 'wrong';
    toggleWrongModeBtn.textContent = 'í‹€ë¦° ë¬¸ì œë§Œ ë³´ê¸°: ì¼¬';
  } else {
    mode = 'all';
    toggleWrongModeBtn.textContent = 'í‹€ë¦° ë¬¸ì œë§Œ ë³´ê¸°: ë”';
  }
  currentIndex = 0;
  displayCurrent();
});

shuffleBtn.addEventListener('click', () => {
  buildWorkList();
  displayCurrent();
});

clearWrongBtn.addEventListener('click', () => {
  if (!confirm('ì •ë§ë¡œ í‹€ë¦° ë¬¸ì œ ëª©ë¡ì„ ì´ˆê¸°í™” í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
  wrongSet = new Set();
  saveWrongSet();
  displayCurrent();
});

exportWrongBtn.addEventListener('click', () => {
  // í‹€ë¦° ë¬¸ì œë“¤ì„ í…ìŠ¤íŠ¸ë¡œ ë¬¶ì–´ ë‹¤ìš´ë¡œë“œ
  const list = rawQuestions.filter(q => wrongSet.has(q.num)).map(q => `${q.num}. ${q.text}`);
  const blob = new Blob([list.join('\n\n')], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'í‹€ë¦°ë¬¸ì œ.txt';
  a.click();
  URL.revokeObjectURL(url);
});

function saveWrongSet() {
  localStorage.setItem('quiz_wrong_list', JSON.stringify(Array.from(wrongSet)));
}

loadBtn.addEventListener('click', async () => {
  if (!fileQ.files[0] || !fileA.files[0]) {
    alert('ë¬¸ì œ íŒŒì¼ê³¼ ì •ë‹µ íŒŒì¼ì„ ë‘˜ ë‹¤ ì„ íƒí•˜ì„¸ìš”.');
    return;
  }
  try {
    const qText = await readFileAsText(fileQ.files[0]);
    const aText = await readFileAsText(fileA.files[0]);
    rawQuestions = splitQuestions(qText);
    answers = parseAnswers(aText); // answers[0] -> 1ë²ˆ ë¬¸ì œì˜ ì •ë‹µ
    // Ensure answers array has length at least max question number
    const maxNum = rawQuestions.reduce((m,q)=>Math.max(m,q.num),0);
    while (answers.length < maxNum) answers.push('');
    buildWorkList();
    mode = 'all';
    toggleWrongModeBtn.textContent = 'í‹€ë¦° ë¬¸ì œë§Œ ë³´ê¸°: ë”';
    currentIndex = 0;
    displayCurrent();
    quizArea.style.display = 'block';
  } catch (err) {
    console.error(err);
    alert('íŒŒì¼ ì½ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
  }
});

// ì´ˆê¸° ìƒíƒœ: í‘œì‹œí•  ë‚´ìš©
displayCurrent();
</script>
</body>
</html>
