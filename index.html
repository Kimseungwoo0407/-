<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>ê³µë¶€ í€´ì¦ˆ (ê³µë¶€ + ëª¨ì˜ê³ ì‚¬ í†µí•©)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body {
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:#f3f6fb; color:#1f2937; padding:22px;
  }
  .container{
    max-width:900px; margin:24px auto; background:white; padding:22px;
    border-radius:12px; box-shadow:0 6px 24px rgba(16,24,40,0.08);
  }
  h1{ margin:0 0 10px 0; font-size:22px; }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; margin:12px 0; }
  button{
    padding:10px 14px; border-radius:8px; border:0; cursor:pointer; font-weight:600;
  }
  .btn-primary{ background:#2563eb; color:white; }
  .btn-success{ background:#16a34a; color:white; }
  .btn-danger{ background:#dc2626; color:white; }
  .btn-muted{ background:#e5e7eb; color:#111827; }
  pre{
    white-space:pre-wrap; text-align:left; background:#f8fafc;
    padding:16px; border-radius:8px; font-size:16px;
  }
  #answer { margin-top:10px; font-weight:700; color:#0f172a; }
  .meta{ font-size:13px; color:#6b7280; margin-top:8px; }
</style>
</head>
<body>
  <div class="container">
    <h1>ğŸ§  NVIDIA ìê²© ëŒ€ë¹„ í€´ì¦ˆ</h1>
    <p class="meta">
      ê°™ì€ í´ë”ì˜ <code>ë¬¸ì œ.txt / ì •ë‹µ.txt</code> ë˜ëŠ”
      <code>ëª¨ì˜ê³ ì‚¬_ë¬¸ì œ.txt / ëª¨ì˜ê³ ì‚¬_ì •ë‹µ.txt</code>ë¥¼ ìë™ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.
    </p>

    <div class="controls">
      <button id="startExamBtn" class="btn-primary">ğŸ ëª¨ì˜ê³ ì‚¬ ì‹œì‘</button>
    </div>

    <div id="quizArea" style="display:none;">
      <div class="meta" id="metaInfo"></div>
      <pre id="questionBox">ë¬¸ì œê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</pre>

      <div class="controls" id="buttonBox">
        <button id="showAnswerBtn" class="btn-muted">ì •ë‹µ ë³´ê¸°</button>
        <button id="correctBtn" class="btn-success">ë§ìŒ âœ…</button>
        <button id="wrongBtn" class="btn-danger">í‹€ë¦¼ âŒ</button>
        <button id="nextBtn" class="btn-primary">ë‹¤ìŒ â–¶</button>
        <button id="toggleWrongMode" class="btn-muted">í‹€ë¦° ë¬¸ì œë§Œ ë³´ê¸°: ë”</button>
        <button id="shuffleBtn" class="btn-muted">ë‹¤ì‹œ ì„ê¸° ğŸ”€</button>
        <button id="clearWrong" class="btn-muted">í‹€ë¦°ë¬¸ì œ ì´ˆê¸°í™”</button>
        <button id="exportWrong" class="btn-muted">í‹€ë¦°ë¬¸ì œ ë‚´ë³´ë‚´ê¸°(.txt)</button>
      </div>

      <div id="answer" style="display:none;"></div>
      <div class="meta" id="progress"></div>
    </div>
  </div>

<script>
let rawQuestions = [];      // { num, stem, options: [{label,text}], correctIndex }
let answers = [];           // ì •ë‹µ í…ìŠ¤íŠ¸ (ì›ë³¸)
let workList = [];
let currentIndex = 0;
let wrongSet = new Set(JSON.parse(localStorage.getItem('quiz_wrong_list') || '[]'));
let mode = 'all';
let examMode = false;
let examIndex = 0;
let score = 0;

const quizArea = document.getElementById('quizArea');
const questionBox = document.getElementById('questionBox');
const answerDiv = document.getElementById('answer');
const showAnswerBtn = document.getElementById('showAnswerBtn');
const correctBtn = document.getElementById('correctBtn');
const wrongBtn = document.getElementById('wrongBtn');
const nextBtn = document.getElementById('nextBtn');
const metaInfo = document.getElementById('metaInfo');
const progress = document.getElementById('progress');
const toggleWrongModeBtn = document.getElementById('toggleWrongMode');
const shuffleBtn = document.getElementById('shuffleBtn');
const clearWrongBtn = document.getElementById('clearWrong');
const exportWrongBtn = document.getElementById('exportWrong');
const startExamBtn = document.getElementById('startExamBtn');
const buttonBox = document.getElementById('buttonBox');

// ===================== ê³µí†µ ìœ í‹¸ =====================
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// ë¬¸ì œ ë¸”ë¡ ë‚˜ëˆ„ê¸° (ë¬¸ì œ ë²ˆí˜¸ ê¸°ì¤€)
function splitQuestions(text) {
  const trimmed = text.trim();
  const lines = trimmed.split(/\r?\n/);
  const questions = [];
  let current = '';

  for (const line of lines) {
    if (/^\s*\d+\./.test(line)) {
      if (current.trim()) questions.push(current.trim());
      current = line;
    } else {
      current += '\n' + line;
    }
  }
  if (current.trim()) questions.push(current.trim());

  return questions.map(q => {
    const match = q.match(/^\s*(\d+)\./);
    const num = match ? parseInt(match[1], 10) : null;
    return { num, rawText: q };
  });
}

// ì •ë‹µ í…ìŠ¤íŠ¸ íŒŒì‹±
function parseAnswers(text) {
  const lines = text.split(/\r?\n/)
    .map(s => s.trim())
    .filter(s => s.length > 0);
  return lines.map(l => l.replace(/^\s*\d+\.\s*/, '').trim());
}

// í•œ ë¬¸ì œì—ì„œ stem + options ì¶”ì¶œ
// í˜•ì‹ ì˜ˆ: "1. ì§ˆë¬¸...? â‘  ë³´ê¸°1 â‘¡ ë³´ê¸°2 â‘¢ ë³´ê¸°3 â‘£ ë³´ê¸°4"
function extractStemAndOptions(rawText) {
  // ì•ì˜ "ë²ˆí˜¸." ì œê±°
  let body = rawText.replace(/^\s*\d+\.\s*/, '').trim();

  const firstOptMatch = body.match(/[â‘ â‘¡â‘¢â‘£]/);
  if (!firstOptMatch) {
    // ì„ íƒì§€ê°€ ì—†ëŠ” ê²½ìš° (ê±°ì˜ ì—†ê² ì§€ë§Œ)
    return { stem: body, options: [] };
  }

  const stem = body.slice(0, firstOptMatch.index).trim();
  const optsStr = body.slice(firstOptMatch.index);

  const parts = optsStr.split(/(?=[â‘ â‘¡â‘¢â‘£])/);
  const options = parts.map(p => {
    const m = p.trim().match(/^([â‘ â‘¡â‘¢â‘£])\s*(.*)$/);
    if (!m) return null;
    return { label: m[1], text: m[2].trim() };
  }).filter(Boolean);

  return { stem, options };
}

// ì§ˆë¬¸ + ì •ë‹µ í…ìŠ¤íŠ¸ë¡œ êµ¬ì¡°í™” + ë³´ê¸° ì„ê¸°
function prepareQuestions(questionBlocks, answers) {
  const labels = ['â‘ ','â‘¡','â‘¢','â‘£'];

  return questionBlocks.map((qBlock, idx) => {
    const { stem, options } = extractStemAndOptions(qBlock.rawText);
    const answerText = answers[idx];

    // ì •ë‹µì´ ë“¤ì–´ ìˆëŠ” ì›ë˜ ì˜µì…˜ ì¸ë±ìŠ¤ ì°¾ê¸°
    let correctIdx = options.findIndex(o => o.text.includes(answerText));
    if (correctIdx < 0) correctIdx = 0; // ëª» ì°¾ìœ¼ë©´ 0ìœ¼ë¡œ ê°•ì œ

    // ì„ê¸° ì¤€ë¹„ (ì›ë˜ ì¸ë±ìŠ¤ë¥¼ ê°™ì´ ë“¤ê³  ê°„ë‹¤)
    const optWithIndex = options.map((opt, i) => ({ idx: i, text: opt.text }));
    shuffle(optWithIndex);

    // ì„ì¸ í›„ ìƒˆ ì˜µì…˜ + ë¼ë²¨ ì¬ë¶€ì—¬
    const shuffledOptions = optWithIndex.map((o, i) => ({
      label: labels[i] || '',
      text: o.text
    }));

    // ì„ì¸ ë°°ì—´ì—ì„œ ì •ë‹µ ìœ„ì¹˜
    const newCorrectIndex = optWithIndex.findIndex(o => o.idx === correctIdx);

    return {
      num: qBlock.num,
      stem,
      options: shuffledOptions,
      correctIndex: newCorrectIndex,
      answerText // ë””ë²„ê·¸/ë°±ì—…ìš©
    };
  });
}

// í™”ë©´ ì¶œë ¥ìš© ë¬¸ìì—´ë¡œ ë³€í™˜
function formatQuestionDisplay(q, indexForExam = null) {
  // indexForExamì´ ìˆìœ¼ë©´ "1. " ì´ë ‡ê²Œ ëª¨ì˜ê³ ì‚¬ìš© ë²ˆí˜¸, ì—†ìœ¼ë©´ ì›ë˜ ë²ˆí˜¸ ì‚¬ìš©
  const qNum = indexForExam != null ? indexForExam : q.num;
  const lines = [];
  lines.push(`${qNum}. ${q.stem}`);
  q.options.forEach(o => {
    lines.push(`${o.label} ${o.text}`);
  });
  return lines.join('\n');
}

// ===================== ìƒíƒœ ê´€ë ¨ =====================
function buildWorkList() {
  workList = rawQuestions.slice();
  shuffle(workList);
  currentIndex = 0;
}

function saveWrongSet() {
  localStorage.setItem('quiz_wrong_list', JSON.stringify(Array.from(wrongSet)));
}

function getCurrentQuestion() {
  if (mode === 'wrong') {
    const wrongArray = workList.filter(q => wrongSet.has(q.num));
    return wrongArray[currentIndex] || null;
  } else {
    return workList[currentIndex] || null;
  }
}

// ===================== í™”ë©´ í‘œì‹œ (ê³µë¶€ ëª¨ë“œ) =====================
function displayCurrent() {
  answerDiv.style.display = 'none';
  answerDiv.textContent = '';
  quizArea.style.display = 'block';

  if (mode === 'wrong') {
    const wrongArray = workList.filter(q => wrongSet.has(q.num));
    if (wrongArray.length === 0) {
      questionBox.textContent = 'ğŸ“š í‹€ë¦° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.';
      progress.textContent = '';
      metaInfo.textContent = '';
      return;
    }
    const q = wrongArray[currentIndex] || wrongArray[0];
    questionBox.textContent = formatQuestionDisplay(q);
    progress.textContent = `${currentIndex + 1} / ${wrongArray.length} (í‹€ë¦° ë¬¸ì œë§Œ)`;
    metaInfo.textContent = `ì „ì²´ ë¬¸ì œ: ${rawQuestions.length} / í‹€ë¦° ë¬¸ì œ: ${wrongSet.size}`;
    return;
  }

  if (workList.length === 0) return;
  const q = workList[currentIndex];
  questionBox.textContent = formatQuestionDisplay(q);
  progress.textContent = `${currentIndex + 1} / ${workList.length} (ì „ì²´ ëª¨ë“œ)`;
  metaInfo.textContent = `ì „ì²´ ë¬¸ì œ: ${rawQuestions.length} / í‹€ë¦° ë¬¸ì œ: ${wrongSet.size}`;
}

function nextQuestion() {
  const list = (mode === 'wrong')
    ? workList.filter(q => wrongSet.has(q.num))
    : workList;
  if (list.length === 0) return;
  currentIndex = (currentIndex + 1) % list.length;
  displayCurrent();
}

// ===================== ë²„íŠ¼ ì´ë²¤íŠ¸ (ê³µë¶€ ëª¨ë“œ) =====================
showAnswerBtn.addEventListener('click', () => {
  if (examMode) return;
  const q = getCurrentQuestion();
  if (!q) return;
  answerDiv.style.display = 'block';
  if (q.options.length && q.correctIndex >= 0) {
    const opt = q.options[q.correctIndex];
    answerDiv.textContent = `ì •ë‹µ: ${opt.label} ${opt.text}`;
  } else {
    // í˜¹ì‹œ ì˜µì…˜ íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì›ë³¸ ì •ë‹µ í…ìŠ¤íŠ¸ë¼ë„ ë³´ì—¬ì¤Œ
    const ansText = answers[q.num - 1] || q.answerText || 'ì •ë‹µ ì •ë³´ ì—†ìŒ';
    answerDiv.textContent = `ì •ë‹µ: ${ansText}`;
  }
});

correctBtn.addEventListener('click', () => {
  if (examMode) return;
  const q = getCurrentQuestion(); if (!q) return;
  wrongSet.delete(q.num);
  saveWrongSet();
  nextQuestion();
});

wrongBtn.addEventListener('click', () => {
  if (examMode) return;
  const q = getCurrentQuestion(); if (!q) return;
  wrongSet.add(q.num);
  saveWrongSet();
  nextQuestion();
});

nextBtn.addEventListener('click', nextQuestion);

toggleWrongModeBtn.addEventListener('click', () => {
  if (examMode) return;
  mode = (mode === 'all') ? 'wrong' : 'all';
  toggleWrongModeBtn.textContent = `í‹€ë¦° ë¬¸ì œë§Œ ë³´ê¸°: ${mode === 'wrong' ? 'ì¼¬' : 'ë”'}`;
  currentIndex = 0;
  displayCurrent();
});

shuffleBtn.addEventListener('click', () => {
  if (!examMode) {
    buildWorkList();
    displayCurrent();
  }
});

clearWrongBtn.addEventListener('click', () => {
  if (examMode) return;
  if (!confirm('í‹€ë¦° ë¬¸ì œ ê¸°ë¡ì„ ì´ˆê¸°í™”í• ê¹Œìš”?')) return;
  wrongSet = new Set();
  saveWrongSet();
  displayCurrent();
});

exportWrongBtn.addEventListener('click', () => {
  if (examMode) return;
  const list = rawQuestions
    .filter(q => wrongSet.has(q.num))
    .map(q => formatQuestionDisplay(q));
  const blob = new Blob([list.join('\n\n')], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'í‹€ë¦°ë¬¸ì œ.txt'; a.click();
  URL.revokeObjectURL(url);
});

// ===================== íŒŒì¼ ë¡œë“œ =====================
window.addEventListener("DOMContentLoaded", async () => {
  await loadFiles(false); // ê¸°ë³¸ ê³µë¶€ ëª¨ë“œ
});

async function loadFiles(isExam = false) {
  const filePrefix = isExam ? "ëª¨ì˜ê³ ì‚¬_" : "";
  try {
    const [qRes, aRes] = await Promise.all([
      fetch(`${filePrefix}ë¬¸ì œ.txt`),
      fetch(`${filePrefix}ì •ë‹µ.txt`)
    ]);
    if (!qRes.ok || !aRes.ok) {
      questionBox.textContent = `âš ï¸ ${filePrefix}ë¬¸ì œ.txt ë˜ëŠ” ${filePrefix}ì •ë‹µ.txtë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`;
      return;
    }
    const qText = await qRes.text();
    const aText = await aRes.text();

    const questionBlocks = splitQuestions(qText);
    answers = parseAnswers(aText);
    rawQuestions = prepareQuestions(questionBlocks, answers);

    if (isExam) startExamMode();
    else {
      examMode = false;
      buttonBox.style.display = 'flex';
      buildWorkList();
      displayCurrent();
    }
  } catch (err) {
    questionBox.textContent = "íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜: " + err;
  }
}

// ===================== ëª¨ì˜ê³ ì‚¬ ëª¨ë“œ =====================
startExamBtn.addEventListener('click', async () => {
  if (!confirm("ëª¨ì˜ê³ ì‚¬ë¥¼ ì‹œì‘í• ê¹Œìš”? (50ë¬¸í•­ ëœë¤)")) return;
  await loadFiles(true);
});

function startExamMode() {
  examMode = true;
  quizArea.style.display = 'block';
  buttonBox.style.display = 'none';

  // ëª¨ì˜ê³ ì‚¬ìš© ë¬¸ì œ ë¦¬ìŠ¤íŠ¸: ì²« 50ê°œì—ì„œ ì„ê¸° (ë¬¸ì œ ìˆ˜ê°€ 50 ì´ìƒì´ë¼ê³  ê°€ì •)
  workList = rawQuestions.slice(0, 50);
  shuffle(workList);
  examIndex = 0;
  score = 0;
  showExamQuestion();
}

function showExamQuestion() {
  const q = workList[examIndex];
  questionBox.textContent = formatQuestionDisplay(q, examIndex + 1);
  answerDiv.style.display = 'none';
  progress.textContent = `ë¬¸í•­ ${examIndex + 1} / ${workList.length}`;
  metaInfo.textContent = `í˜„ì¬ ì ìˆ˜: ${score}`;
}

// ìˆ«ìí‚¤(1~4)ë¡œ ë‹µ ì…ë ¥
document.addEventListener("keydown", (e) => {
  if (!examMode) return;
  if (e.key >= "1" && e.key <= "4") {
    const choiceIdx = parseInt(e.key, 10) - 1; // 0~3
    const q = workList[examIndex];

    const isCorrect = (choiceIdx === q.correctIndex);
    if (isCorrect) score++;

    examIndex++;
    if (examIndex >= workList.length) showExamResult();
    else showExamQuestion();
  }
});

function showExamResult() {
  const percent = (score / workList.length * 100).toFixed(1);
  questionBox.textContent =
    `âœ… ì‹œí—˜ ì¢…ë£Œ!\në‹¹ì‹ ì˜ ì ìˆ˜: ${score} / ${workList.length} (${percent}%)`;
  answerDiv.textContent =
    percent >= 90 ? "ğŸ‰ ë§Œì  ìˆ˜ì¤€!" :
    percent >= 70 ? "ğŸ‘ í•©ê²© ê°€ëŠ¥" :
                    "âš ï¸ ì¶”ê°€ ë³µìŠµ í•„ìš”";
  answerDiv.style.display = "block";
}
</script>
</body>
</html>
